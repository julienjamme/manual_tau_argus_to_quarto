<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Manual of Tau-Argus - 2&nbsp; Producing Safe Tables</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./03_A_tour_of_τ-ARGUS.html" rel="next">
<link href="./01_Introduction.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./02_Producing_Safe_tables.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Producing Safe Tables</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Manual of Tau-Argus</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="math inline">\(\tau\)</span>-ARGUS User’s Manual</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_Introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_Producing_Safe_tables.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Producing Safe Tables</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_A_tour_of_τ-ARGUS.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">A tour of <span class="math inline">\(\tau\)</span>-Argus</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_Reference_Section_-_Description_of_the_Menu_Items.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Description of the Menu Items</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_Further_descriptions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Further descriptions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_Index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Index</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">2.1</span> Introduction</a></li>
  <li><a href="#sensitive-cells-in-magnitude-tables5" id="toc-sensitive-cells-in-magnitude-tables5" class="nav-link" data-scroll-target="#sensitive-cells-in-magnitude-tables5"><span class="header-section-number">2.2</span> Sensitive cells in magnitude tables</a></li>
  <li><a href="#sensitive-cells-in-frequency-count-tables" id="toc-sensitive-cells-in-frequency-count-tables" class="nav-link" data-scroll-target="#sensitive-cells-in-frequency-count-tables"><span class="header-section-number">2.3</span> Sensitive cells in frequency count tables</a></li>
  <li><a href="#table-redesign" id="toc-table-redesign" class="nav-link" data-scroll-target="#table-redesign"><span class="header-section-number">2.4</span> Table redesign</a></li>
  <li><a href="#secondary-cell-suppression" id="toc-secondary-cell-suppression" class="nav-link" data-scroll-target="#secondary-cell-suppression"><span class="header-section-number">2.5</span> Secondary cell suppression</a></li>
  <li><a href="#information-loss-in-terms-of-cell-costs8" id="toc-information-loss-in-terms-of-cell-costs8" class="nav-link" data-scroll-target="#information-loss-in-terms-of-cell-costs8"><span class="header-section-number">2.6</span> Information loss in terms of cell costs</a></li>
  <li><a href="#series-of-tables" id="toc-series-of-tables" class="nav-link" data-scroll-target="#series-of-tables"><span class="header-section-number">2.7</span> Series of tables</a></li>
  <li><a href="#the-hypercubeghmiter-method9" id="toc-the-hypercubeghmiter-method9" class="nav-link" data-scroll-target="#the-hypercubeghmiter-method9"><span class="header-section-number">2.8</span> The Hypercube/GHMITER method</a>
  <ul class="collapse">
  <li><a href="#the-hypercube-method" id="toc-the-hypercube-method" class="nav-link" data-scroll-target="#the-hypercube-method"><span class="header-section-number">2.8.1</span> The hypercube method</a></li>
  <li><a href="#the-argus-implementation-of-ghmiter" id="toc-the-argus-implementation-of-ghmiter" class="nav-link" data-scroll-target="#the-argus-implementation-of-ghmiter"><span class="header-section-number">2.8.2</span> The ARGUS implementation of GHMITER</a></li>
  <li><a href="#references-on-ghmiter" id="toc-references-on-ghmiter" class="nav-link" data-scroll-target="#references-on-ghmiter"><span class="header-section-number">2.8.3</span> References on GHMITER</a></li>
  </ul></li>
  <li><a href="#optimisation-models-for-secondary-cell-suppression10" id="toc-optimisation-models-for-secondary-cell-suppression10" class="nav-link" data-scroll-target="#optimisation-models-for-secondary-cell-suppression10"><span class="header-section-number">2.9</span> Optimisation models for secondary cell suppression</a></li>
  <li><a href="#sec-modularapproach" id="toc-sec-modularapproach" class="nav-link" data-scroll-target="#sec-modularapproach"><span class="header-section-number">2.10</span> The Modular approach</a>
  <ul class="collapse">
  <li><a href="#references-on-the-modular-method" id="toc-references-on-the-modular-method" class="nav-link" data-scroll-target="#references-on-the-modular-method"><span class="header-section-number">2.10.1</span> References on the modular method</a></li>
  </ul></li>
  <li><a href="#sec-modularlinkedtables" id="toc-sec-modularlinkedtables" class="nav-link" data-scroll-target="#sec-modularlinkedtables"><span class="header-section-number">2.11</span> The modular approach for linked tables</a>
  <ul class="collapse">
  <li><a href="#references-on-the-modular-approach-for-linked-tables" id="toc-references-on-the-modular-approach-for-linked-tables" class="nav-link" data-scroll-target="#references-on-the-modular-approach-for-linked-tables"><span class="header-section-number">2.11.1</span> References on the modular approach for linked tables</a></li>
  </ul></li>
  <li><a href="#network-solution-for-large-2-dimensional-tables-with-one-hierarchy" id="toc-network-solution-for-large-2-dimensional-tables-with-one-hierarchy" class="nav-link" data-scroll-target="#network-solution-for-large-2-dimensional-tables-with-one-hierarchy"><span class="header-section-number">2.12</span> Network solution for large 2 dimensional tables with one hierarchy</a>
  <ul class="collapse">
  <li><a href="#references-on-the-network-solution" id="toc-references-on-the-network-solution" class="nav-link" data-scroll-target="#references-on-the-network-solution"><span class="header-section-number">2.12.1</span> References on the network solution</a></li>
  </ul></li>
  <li><a href="#controlled-tabular-adjustment12" id="toc-controlled-tabular-adjustment12" class="nav-link" data-scroll-target="#controlled-tabular-adjustment12"><span class="header-section-number">2.13</span> Controlled Tabular Adjustment</a>
  <ul class="collapse">
  <li><a href="#references-on-the-controlled-tabular-adjustment-solution" id="toc-references-on-the-controlled-tabular-adjustment-solution" class="nav-link" data-scroll-target="#references-on-the-controlled-tabular-adjustment-solution"><span class="header-section-number">2.13.1</span> References on the controlled tabular adjustment solution</a></li>
  </ul></li>
  <li><a href="#controlled-rounding13" id="toc-controlled-rounding13" class="nav-link" data-scroll-target="#controlled-rounding13"><span class="header-section-number">2.14</span> Controlled rounding</a>
  <ul class="collapse">
  <li><a href="#restricted-and-non-restricted-controlled-rounding" id="toc-restricted-and-non-restricted-controlled-rounding" class="nav-link" data-scroll-target="#restricted-and-non-restricted-controlled-rounding"><span class="header-section-number">2.14.1</span> Restricted and non-restricted controlled rounding</a></li>
  <li><a href="#optimal-first-feasible-and-rapid-solutions14" id="toc-optimal-first-feasible-and-rapid-solutions14" class="nav-link" data-scroll-target="#optimal-first-feasible-and-rapid-solutions14"><span class="header-section-number">2.14.2</span> Optimal, first feasible and RAPID solutions</a></li>
  <li><a href="#protection-provided-by-controlled-rounding" id="toc-protection-provided-by-controlled-rounding" class="nav-link" data-scroll-target="#protection-provided-by-controlled-rounding"><span class="header-section-number">2.14.3</span> Protection provided by controlled rounding</a></li>
  <li><a href="#choosing-the-parameters-for-controlled-rounding" id="toc-choosing-the-parameters-for-controlled-rounding" class="nav-link" data-scroll-target="#choosing-the-parameters-for-controlled-rounding"><span class="header-section-number">2.14.4</span> Choosing the parameters for Controlled Rounding</a></li>
  </ul></li>
  <li><a href="#audit" id="toc-audit" class="nav-link" data-scroll-target="#audit"><span class="header-section-number">2.15</span> Audit</a>
  <ul class="collapse">
  <li><a href="#auditing-a-hierarchical-table" id="toc-auditing-a-hierarchical-table" class="nav-link" data-scroll-target="#auditing-a-hierarchical-table"><span class="header-section-number">2.15.1</span> Auditing a hierarchical table</a></li>
  <li><a href="#discovering-singleton-problems" id="toc-discovering-singleton-problems" class="nav-link" data-scroll-target="#discovering-singleton-problems"><span class="header-section-number">2.15.2</span> Discovering singleton problems</a></li>
  </ul></li>
  <li><a href="#functional-design-of-tau-argus" id="toc-functional-design-of-tau-argus" class="nav-link" data-scroll-target="#functional-design-of-tau-argus"><span class="header-section-number">2.16</span> Functional design of <span class="math inline">\(\tau\)</span>-Argus</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-producingSafeTables" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Producing Safe Tables</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">2.1</span> Introduction</h2>
<p>The growing demands from researchers, policy makers and others for more and more detailed statistical information lead to a conflict. Statistical offices collect large amounts of data for statistical purposes. The respondents are only willing to provide the statistical offices with the required information if they can be certain that these statistical offices will treat their data with the utmost care. This implies that respondents' confidentiality must be guaranteed. This imposes limitations on the amount of detail in the publications. Practice and research have generated insights into how to protect tables, but the problem is not yet definitively solved.</p>
<p>Before we go into more details of the basic ideas on which <span class="math inline">\(\tau\)</span>-Argus is based, we give a sketch of the general ideas. At first sight one might find it difficult to understand that information presented in tabular form presents a disclosure risk. After all, one might say that the information is presented only in aggregate form.</p>
<p>Safe tables are produced from unsafe ones by applying certain SDC measures to the tables. These SDC measures - as far as they are implemented in <span class="math inline">\(\tau\)</span>-Argus - are discussed in the present section. Some key concepts such as sensitive cells, information loss and the like are discussed as well.</p>
</section>
<section id="sensitive-cells-in-magnitude-tables5" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sensitive-cells-in-magnitude-tables5"><span class="header-section-number">2.2</span> Sensitive cells in magnitude tables<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2>
<p>The well-known <strong>dominance rule</strong> is often used to find the sensitive cells in tables, i.e.&nbsp;the cells that cannot be published as they might reveal information on individual respondents. More particularly, this rule states that a cell of a table is unsafe for publication if a few (<span class="math inline">\(n\)</span>) major (largest) contributors to a cell are responsible for acertain percentage (<span class="math inline">\(k\)</span>) of the total of that cell. The idea behind this rule is that in that case at least the major contributors themselves can determine with sufficient precision the contributions of the other contributors to that cell. The choice <span class="math inline">\(n=3\)</span> and <span class="math inline">\(k=70\)</span>% is not uncommon, but <span class="math inline">\(\tau\)</span>-Argus will allow the users to specify their own values of <span class="math inline">\(n\)</span> and <span class="math inline">\(k\)</span>.</p>
<p>As an alternative the <strong>prior-posterior rule</strong> has been proposed. The basic idea is that a contributor to a cell has a better chance to estimate competitors in a cell than an outsider, and also that these kind of intrusions can occur rather often. The precision with which a competitor can estimate is a measure of the sensitivity of a cell. The worst case is that the second largest contributor will be able to estimate the largest contributor. If this precision is more than <span class="math inline">\(p\)</span>%, the cell is considered unsafe. An extension is that also the global knowledge about each cell is taken into account. In that case we assume that each intruder has a basic knowledge of the value of each contributor of <span class="math inline">\(q\)</span>%. Note, that it is actually the ratio <span class="math inline">\(p/q\)</span> that determines which cells are considered safe, or unsafe. In this version of <span class="math inline">\(\tau\)</span>-Argus, the <span class="math inline">\(q\)</span>‑parameter is fixed to <span class="math inline">\(100\)</span>. Literature refers to this rule as <strong>(minimum protection of) <span class="math inline">\(p\)</span>%‑rule</strong>. If the intention is to state a prior-posterior rule with parameters <span class="math inline">\(p_0\)</span> and <span class="math inline">\(q_0\)</span>, where <span class="math inline">\(q_0 &lt; 100\)</span>, choose the parameter <span class="math inline">\(p\)</span> of the <span class="math inline">\(p\)</span>%‑rule as <span class="math inline">\(p = p_0/q_0 \times 100\)</span>. See Loeve (2001)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>With these rules as a starting point it is easy to identify the sensitive cells, provided that the tabulation package has the facility not only to calculate the cell totals, but also to calculate the number of contributors and the <span class="math inline">\(n\)</span> individual contributions of the major contributors. Tabulation packages like ABACUS (from Statistics Netherlands) and the package ‘SuperCross’ developed in Australia by Space-Time Research have that capacity. In fact <span class="math inline">\(\tau\)</span>-Argus not only stores the sum of the <span class="math inline">\(n\)</span> major contributions for each cell, but the individual major contributions themselves. The reason for this is that this is very handy in case rows and columns etc. in a table are combined. By merging and sorting the sets of individual contributions of the cells to be combined, one can quickly determine the major contributions of the new cell, without going back to the original file. This implies that one can quickly apply the dominance rule or the <span class="math inline">\(p\)</span>%-rule to the combined cells. Combining rows and columns (table redesign) is one of the major tools for reducing the number of unsafe cells.</p>
<p>This too is the reason why <span class="math inline">\(\tau\)</span>-Argus can read microdata files and build the tables itself. However due to continuous demands from users we have now also provide the option to read ready-made tables, but with the restriction that the options for table redesign will not be available in that case.</p>
<p>A problem, however, arises when also the marginals of the table are published. It is no longer enough to just suppress the sensitive cells, as they can be easily recalculated using the marginals. Even if it is not possible to exactly recalculate the suppressed cell, it is possible to calculate an interval that contains the suppressed cell. This is possible if some constraints are known to hold for the cell values in a table. A commonly found constraint is that the cell values are all nonnegative.</p>
<p>If the size of such an interval is rather small, then the suppressed cell can be estimated rather precisely. This is not acceptable either. Therefore it is necessary to suppress additional information to achieve sufficiently large intervals.</p>
<p>Several solutions are available to protect the information of the sensitive cells:</p>
<ul>
<li><p>Combining categories of the spanning variables (table redesign). Larger cells tend to protect the information about the individual contributors better.</p></li>
<li><p>Suppression of additional (secondary) cells to prevent the recalculation of the sensitive (primary) cells.</p></li>
</ul>
<p>The calculation of the optimal set (with respect to the loss of information) of secondary cells is a complex OR-problem. <span class="math inline">\(\tau\)</span>-Argus has been built around this solution, and takes care of the whole process. A typical <span class="math inline">\(\tau\)</span>-Argus session will be one in which the users will first be presented with the table containing only the primary unsafe cells. The user can then choose how to protect these cells. This can involve the combining of categories, equivalent to the global recoding of <span class="math inline">\(\mu\)</span>-Argus. The result will be an update of the table with fewer unsafe cells(certainly not more) if the recoding has worked. At a certain stage the user requests the system to solve the remaining unsafe cells by finding secondary cells to protect the primary cells.</p>
<p>At this stage the user can choose between several options to protect the primary sensitive cells. Either they choose the hypercube method or the optimal solution. In this case they also has to select the solver to be used, Xpress or cplex or the free solver soplex. After this, the table can be stored for further processing if necessary, and eventual publication.</p>
</section>
<section id="sensitive-cells-in-frequency-count-tables" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sensitive-cells-in-frequency-count-tables"><span class="header-section-number">2.3</span> Sensitive cells in frequency count tables</h2>
<p>In the simplest way of using <span class="math inline">\(\tau\)</span>-Argus, sensitive cells in frequency count tables are defined as those cells that contain a frequency that is below a certain threshold value. This threshold value is to be provided by the data protector. This way of identifying unsafe cells in a table is the one that is implemented in the current version of <span class="math inline">\(\tau\)</span>-Argus. It should be remarked, however, that this is not always an adequate way to protect a frequency count table<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. Yet it is applied a lot. Applying a dominance rule or a <span class="math inline">\(p\)</span>% rule is useless in this context. One should think about possible disclosure risks that a frequency count table poses and possible disclosure scenarios in order to simulate the behaviour of an intruder. Such an analysis would probably come up with different insights than using a simple thresholding rule, <em>e.g.</em> like the one sketched in the reference just mentioned. We just mention here the risks of group-disclosure; when a(small) group of respondents have all the same score on a certain category. This risk is often also referred to as the problem of <span class="math inline">\(100\)</span>%-cells. Further research on this topic is being carried out at Statistics Netherlands.</p>
</section>
<section id="table-redesign" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="table-redesign"><span class="header-section-number">2.4</span> Table redesign</h2>
<p>If a large number of sensitive cells are present in a table, it might be an indication that the spanning variables are too detailed. In that case one could consider combining certain rows and columns in the table. (This might not always be possible because of publication policy.) Otherwise the number of secondary cell suppressions might just be too enormous. The situation is comparable to the case of microdata containing many unsafe combinations. Rather than eliminating them with local suppressions one can remove them by using global recodings. For tabular data we use the phrase “table redesign” to denote an operation analogous to global recoding in microdata sets. The idea of table redesign is to combine rows, columns etc., by adding the cell contents of corresponding cells from the different rows, columns etc. It is a property of the sensitivity rules that a joint cell is safer than any of the individual cells. So as a result of this operation the number of unsafe cells is reduced. One can try to eliminate all unsafe combinations in this way, but that might lead to an unacceptably high information loss. Instead, one could stop at some point, and eliminate the remaining unsafe combinations by using other techniques such as cell suppression.</p>
</section>
<section id="secondary-cell-suppression" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="secondary-cell-suppression"><span class="header-section-number">2.5</span> Secondary cell suppression</h2>
<p>Once the sensitive cells in a table have been identified, possibly following table redesign it might be a good idea to suppress these values. In case no constraints on the possible values in the cells of a table exist this is easy: one simply removes the cell values concerned and the problem is solved. In practice, however, this situation hardly ever occurs. Instead one has constraints on the values in the cells due to the presence of marginals and lower bounds for the cell values (typically 0). The problem then is to find additional cells that should be suppressed in order to protect the sensitive cells. The additional cells should be chosen in such a way that the interval of possible values for each sensitive cell value is sufficiently large. What is “sufficiently large” can be specified by the data protector in <span class="math inline">\(\tau\)</span>-Argus by specifying the protection intervals.</p>
<p>In general the secondary cell suppression problem turns out to be a hard problem, provided the aim is to retain as much information in the table as possible, which, of course, is a quite natural requirement. The optimisation problems that will then result are quite difficult to solve and require expert knowledge in the area of combinatorial optimisation.</p>
</section>
<section id="information-loss-in-terms-of-cell-costs8" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="information-loss-in-terms-of-cell-costs8"><span class="header-section-number">2.6</span> Information loss in terms of cell costs<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2>
<p>In case of secondary cell suppression it is possible that a data protector might want to differentiate between the candidate cells for secondary suppression. It is possible that they would strongly prefer to preserve the content of certain cells, and are willing to sacrifice the values of other cells instead. A mechanism that can be used to make such a distinction between cells in a table is that of cell costs. In <span class="math inline">\(\tau\)</span>-Argus it is possible to associate different costs with the cells in a table. The higher the cost the more important the corresponding cell value is considered and the less likely it will be suppressed. We shall interpret this by saying that the cells with the higher associated costs have a higher information content.</p>
<p>The aim of secondary cell suppression can be summarised by saying that a safe table should be produced from an unsafe one, by minimising the information loss, expressed as the sum of the costs associated with the cells that have secondarily been suppressed.</p>
<p><span class="math inline">\(\tau\)</span>-Argus offers several ways to compute these costs. The first option is to compute the costs as the sum of the contributions to a cell. Alternatively another variable in the data file can be used as the cost function. Secondly this cost can be the frequency of the contributors to a cell, and finally each cell can have cost <span class="math inline">\(= 1\)</span>, minimising the number of suppressed cells.</p>
</section>
<section id="series-of-tables" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="series-of-tables"><span class="header-section-number">2.7</span> Series of tables</h2>
<p>In <span class="math inline">\(\tau\)</span>-Argus it is possible to specify a series of tables that will be protected one by one, and independently of each other. It is more efficient to choose this option since <span class="math inline">\(\tau\)</span>-Argus requires only a single run through the microdata in order to produce the tables. But also for the user it is often more attractive to specify a series of tables and let <span class="math inline">\(\tau\)</span>-Argus protect them in a single session, rather than have several independent sessions.</p>
</section>
<section id="the-hypercubeghmiter-method9" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="the-hypercubeghmiter-method9"><span class="header-section-number">2.8</span> The Hypercube/GHMITER method<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></h2>
<p>In order to ensure tractability also of big applications, <span class="math inline">\(\tau\)</span>‑argus interfaces with the ghmiter hypercube method of R. D. Repsilber of the Landesamt für Datenverarbeitung und Statistik in Nordrhein-Westfalen/Germany, offering a quick heuristic solution. The method has been described in depth in Repsilber (1994), Repsilber (1999) and Repsilber (2002), for a briefer description see Giessing and Repsilber (2002).</p>
<section id="the-hypercube-method" class="level3" data-number="2.8.1">
<h3 data-number="2.8.1" class="anchored" data-anchor-id="the-hypercube-method"><span class="header-section-number">2.8.1</span> The hypercube method</h3>
<p>The approach builds on the fact that a suppressed cell in a simple <span class="math inline">\(n\)</span>‑dimensional table without substructure cannot be disclosed exactly if that cell is contained in a pattern of suppressed, nonzero cells, forming the corner points of a hypercube.</p>
<p>The algorithm subdivides n-dimensional tables with hierarchical structure into a set of <span class="math inline">\(n\)</span>-dimensional sub-tables without substructure.These sub-tables are then protected successively in an iterative procedure that starts from the highest level. Successively, for each primary suppression in the current sub-table, all possible hypercubes with this cell as one of the corner points are constructed.</p>
<p>If protection against inferential disclosure is requested, for each hypercube, a lower bound for the width of the suppression interval forthe primary suppression that would result from the suppression of all corner points of the particular hypercube will be estimated. To estimate that bound, it is not necessary to implement the time consuming solution to the corresponding Linear Programming problem. Only if it turns out that the bound is sufficiently large, the hypercube becomes a feasible solution.</p>
<p>If no protection against inferential disclosure is requested, any hypercube will be considered feasible. This may of course lead to somecases of under protection.</p>
<p>For any of the feasible hypercubes, the loss of information associated with the suppression of its corner points is computed. The particular hypercube that leads to minimum information loss is selected, and all its corner points are suppressed.</p>
<p>Note that the information loss concept of the hypercube method is slightly different from the one of the other, linear programming based methods for secondary cell suppression offered by <span class="math inline">\(\tau\)</span>-Argus it operates rather like a two-stage concept. In the first way, the algorithm will look at the number of additional suppressions (additional to those that are already suppressed because they a primary unsafe, or because they were selected as secondary suppression in another subtable) that would be caused by the selection of a particular candidate hypercube. If there is more than one hypercube that would result in the same, smallest number of additional secondary suppressions, at second priority the method will select the one with the smallest sum of costs associated to the suppression of the corresponding additional secondary suppressions. Cell costs associated to a cell are indeed a logarithmic transformation of the cell value plus eventually a large constant, if the cell is a marginal cell of the current sub-table.</p>
<p>After all sub-tables have been protected once, the procedure is repeated in an iterative fashion. Within this procedure, when cells belonging to more than one sub-table are chosen as secondary suppressions in one of these sub-tables, in further processing they will be treated like sensitive cells in the other sub-tables they belong to. The same iterative approach is used for sets of linked tables.</p>
<p>It should be mentioned here that the ‘hypercube criterion’ is a sufficient but not a necessary criterion for a ‘safe’ suppression pattern. Thus, for particular subtables the ‘best’ suppression patternmay not be a set of hypercubes – in which case, of course, thehypercube method will miss the best solution and lead to some over-protection. Other simplifications of the heuristic approach that add to this tendency for over‑suppression are the following: when assessing the feasibility of a hypercube to protect specific target suppressions against interval disclosure, the method</p>
<ul>
<li><p>is not able to consider protection maybe already provided by other cell suppressions (suppressed cells that are not corner points of this hypercube) within the same sub‑table,</p></li>
<li><p>does not consider the sensitivity of multi‑contributor primary suppressions properly, that is, it does not consider the protection already provided in advance of cell suppression through aggregation of these contributions,</p></li>
<li><p>attempts to provide the same <em>relative</em> ambiguity to (eventually large) secondary suppressions that have been selected to protect cells in a linked sub‑table, as if they were single‑respondent primary suppressions, while actually it would be enough to provide the same <em>absolute</em> ambiguity as required by the corresponding primary suppressions.</p></li>
</ul>
</section>
<section id="the-argus-implementation-of-ghmiter" class="level3" data-number="2.8.2">
<h3 data-number="2.8.2" class="anchored" data-anchor-id="the-argus-implementation-of-ghmiter"><span class="header-section-number">2.8.2</span> The ARGUS implementation of GHMITER</h3>
<ul>
<li><p>In the implementation offered by argus, ghmiter makes sure that a single respondent cell will never appear to be corner point of one hypercube only, but of two hypercubes at least. Otherwise it could happen that a single respondent, who often can be reasonably assumed to know that he is the only respondent, could use his knowledge on the amount of his own contribution to recalculate the value of any other suppressed corner point of this hypercube.</p></li>
<li><p>As explained above, ghmiter uses an elaborate internal cost assignment mechanism which is essential to achieve an optimal performance (given the natural restrictions of the simple heuristic approach, of course). This mechanism should not be cast out of balance. Therefore, the user’s choice of the cell costs (c.f. [3.1.4], [4.4.4]) does not have any impact, when using the hypercube method.</p></li>
<li><p>For tables presenting magnitude data, if protection against inferential disclosure is requested (see the upper part of the pop-up window below) <span class="math inline">\(\tau\)</span>-Argus will ensure that ghmiter selects secondary suppressions that protect the sensitive cells properly. Only cells will be considered feasible as secondary suppressions that are large enough to give enough protection to the target sensitive cell as explained in Giessing (2003).</p></li>
</ul>
<p><img src="Media/Pictures/10000000000001860000013A300D2794.png" style="width:10.689cm;height:8.599cm"></p>
<ul>
<li><p>The standard implementation of the hypercube is that extra protection is given to singleton cells, i.e.&nbsp;cells with only one contributor. As this contributor knows exactly the cell value he might be able to undo the protection. But this extra protecting can be disabled.</p></li>
<li><p>In order to achieve this, <span class="math inline">\(\tau\)</span>-Argus computes a suitable <em>sliding protection ratio</em> (for explanation see Giessing (2003), <span class="math inline">\(\tau\)</span>-Argus will display the value of this ratio in the report file) to be used by ghmiter. If in the screen above the option “<em>Protection against inferential disclosure required</em>” is inactivated, ghmiter will not check whether secondary suppressions are sufficiently large.</p></li>
<li><p>As mentioned above, ghmiter is unable to 'add' the protection given by multiple hypercubes. In certain situations, it is not possible to provide sufficient protection to a particular sensitive cell (or secondary suppression) by suppression of one single hypercube. In such a case, ghmiter is unable to confirm that this cell has been protected properly, according to the specified <em>sliding protection ratio</em>. It will then reduce the <em>sliding protection ratio</em> automatically, and individually, step by step for those cells, the protection of which the program cannot confirm otherwise. In steps <span class="math inline">\(1\)</span> to <span class="math inline">\(9\)</span> we divide the original ratio by <span class="math inline">\(k\)</span>, values of <span class="math inline">\(k\)</span> from <span class="math inline">\(2\)</span>&nbsp;to&nbsp;<span class="math inline">\(10\)</span>, and if this still does not help, in step 10 we divide by an extremely large value, and finally, if even that does not solve the problem, step 11 will set the ratio to zero). The <span class="math inline">\(\tau\)</span>-Argus report file will display the number of cases where the sliding protection range was reduced by finally confirmed sliding protection ratio.</p></li>
<li><p>Note, that that the number of cases with range reduction reported by this statistic in the report file is very likely to exceed the actual number of cells concerned, because cells belonging to multiple (sub-) tables are counted multiple times. In our experience this concerns particularly the cases, where the protection level was reduced to an‚ ‘infinitely’ small (positive) value (in step 10, see above). Step 10 is usually required to confirm protection of large, high level secondary suppressions, which are likely to appear in multiple tables, especially in processing of linked tables. By the way, terms “reduction of the <em>sliding protection ratio</em>” and “reduction of the <em>protection level</em>” are used synonymously in the report file.</p></li>
<li><p>Note that step 11 will make cells eligible for secondary suppression that <span class="math inline">\(\tau\)</span>-Argus considers as ‘protected’ (so called ‘<em>frozen</em>’ cells, for discussion of this option see for instance Giessing (2003).</p></li>
</ul>
<p>As this is inconsistent with the current view on protected cells in <span class="math inline">\(\tau\)</span>-Argus this will lead to the following error message:</p>
<p><img src="Media/Pictures/100000000000016E0000009C1D394A05.png" style="width:10.301cm;height:4.713cm"></p>
<p>The cell value and the codes of those suppressed <em>frozen</em> cells are then displayed by <span class="math inline">\(\tau\)</span>-Argus : This information is also written in the file “frozen.txt” in the temp-directory.</p>
<p><img src="Media/Pictures/10000000000001A0000002008F41CBDE.png" style="width:11.007cm;height:13.547cm"></p>
<p>When the status of these cells is changed into ‘unprotected’ before re-running the hypercube method, the solution will be a feasible solution for <span class="math inline">\(\tau\)</span>-Argus. Zero cells are consider to be frozen as well inthe hypercube. Those frozen cells can be ignored.</p>
<p><strong>Negative values</strong></p>
<p>The hypercube method has no problems when certain cells are negative.</p>
</section>
<section id="references-on-ghmiter" class="level3" data-number="2.8.3">
<h3 data-number="2.8.3" class="anchored" data-anchor-id="references-on-ghmiter"><span class="header-section-number">2.8.3</span> References on GHMITER</h3>
<ol type="1">
<li>Repsilber, R. D. (1994), ‘Preservation of Confidentiality in Aggregated data’, paper presented at the Second International Seminar on Statistical Confidentiality, Luxembourg, 1994</li>
<li>Repsilber, D. (1999), ‘Das Quaderverfahren’&nbsp;- in Forum der Bundesstatistik, Band 31/1999: Methoden zur Sicherung der Statistischen Geheimhaltung, (in German)</li>
<li>Repsilber, D. (2002), ‘Sicherung persönlicher Angaben in Tabellendaten’&nbsp;- in Statistische Analysen und Studien Nordrhein-Westfalen, Landesamt für Datenverarbeitung und Statistik NRW, Ausgabe 1/2002 (in German)</li>
<li>Giessing, S. and Repsilber, D. (2002), ‘Tools and Strategies to Protect Multiple Tables with the GHQUAR Cell Suppression Engine’, in ’<em>Inference Control in Statistical Databases’</em> Domingo-Ferrer (Editor), Springer Lecture Notes in Computer Science Vol. 2316.</li>
<li>Giessing, S. (2003), ‘Co-ordination of Cell Suppressions: strategies for use of GHMITER’, Proceedings of the Joint ECE/Eurostat work session on statistical data confidentiality (Luxembourg, 7-9 April 2003)</li>
</ol>
</section>
</section>
<section id="optimisation-models-for-secondary-cell-suppression10" class="level2" data-number="2.9">
<h2 data-number="2.9" class="anchored" data-anchor-id="optimisation-models-for-secondary-cell-suppression10"><span class="header-section-number">2.9</span> Optimisation models for secondary cell suppression<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></h2>
<p><span class="math inline">\(\tau\)</span>-Argus applies different approaches to find optimal and near-optimal solutions. One of these approaches is based on a Mathematical Programming technique which consists of solving Integer Linear Programming programs modelling the combinatorial problems under different methodologies (Cell Suppression and Controlled Rounding).The main characteristic of these models is that they share the same structure, thus based only on a <span class="math inline">\(0\)</span>-<span class="math inline">\(1\)</span> variable for each cell. In the Cell Suppression methodology, the variable is <span class="math inline">\(1\)</span> if and only if the cell value must be suppressed. In the Controlled Rounding methodology, the variable is <span class="math inline">\(1\)</span> if and only if the cell value must be rounded up. Noother variables are necessary, so the number of variables in the model is exactly the number of cells in the table to be protected. In addition, the model also imposes the protection level requirements(upper, lower and sliding) in the same way for the different methodologies (Cell Suppression and Controlled Rounding). These requirements ask for a guarantee that an attacker will not get too narrow an interval of potential values for a sensitive cell, whichhe/she will compute by solving two linear programming programs (calledattacker problems). Even if a first model containing this two-attacker problem would lead to a bi-level programming model, complex to be solved in practice, a Benders' decomposition approach allows us to convert the attacker problems into a set of linear inequalities. This conversion provides a second model for each methodology that can be efficiently solved by a modern cutting-plane approach. Since the variables are 0-1, a branching phase can be necessary, and the whole approach is named "branch-and-cut algorithm".</p>
<p>Branch-and-cut algorithms are modern techniques in Operations Research that provide excellent results when solving larger and complicated combinatorial problems arising in many applied fields (like routing, scheduling, planning, telecomunications, etc.). Shortly, the idea isto solve a compact <span class="math inline">\(0-1\)</span> model containing a large number of linear inequalities (as the ones above mentioned for the Cell Suppression andfor the Controlled Rounding) through an iterative procedure that does not consider all the inequalities at the same time, but generates the important ones when needed. This dynamic procedure of dealing with large models allows the program to replace the resolution of a hugelarge model by a short sequence of small models, which is termed a "decomposition approach". The on-line generation of the linear inequalities (rows) was also extended in this work to the variables (columns), thus the algorithm can also works on tables with a large number of cells, and the overall algorithm is named "branch-and-cut-and-price" in the Operations Research literature.</p>
<p>To obtain good performance, the implementation has also considered many other ingredients, standard in branch-and-cut-and-price approaches. For example, it is fundamentally the implementation of a pre-processing approach where redundant equations defining the table are eliminated, where variables associated to non-relevant cells are removed, and where dominated protection levels are detected. Thepre-processing is fundamental to make the problem as small as possible before starting the optimization phase. Another fundamental ingredient is the heuristic routine, which allows the algorithm to start with an upper bound of the optimal loss of information. This heuristic routine ensures the production of a protected pattern if the algorithm is interrupted by the user before the end. In other words, thanks to the heuristic routine, the implemented algorithm provide a near-optimal solution if the execution is cancelled before having a proof of optimality. During the implicit enumeration approach (i.e., the branch-and-cut-and-price) the heuristic routine is called several times, thus providing different protected patterns, and the best one will be the optimal solution if its loss of information is equal tothe lower bound. This lower bound is computed by solving a relaxed model, which consists of removing the integrability condition on the integer model. Since the relaxed model is a linear program, a linear programming solver must be called.</p>
<p>We have not implemented our own linear programming solver, but used a commercial solver which is already tested by other programmers for many years. A robust linear programming solver is a guarantee that no numerical trouble will appear during the computation.</p>
<p>That is the reason to requires either cplex (from ILOG) or Xpress(from FICO). Because the model to be solved can be applied to all type of table structures (2-dim, 3-dim, 4-dim, etc), including hierarchical and linked tables, we cannot use special simplex algorithm implementations, like the min-cost flow computation which would required to work with tables that can be modelled as a network (e.g., 2-dimensional tables or collections of 2-dim tables linked by onelink). On this special table, ad-hoc approaches (solving network flowsor short path problems) could be implemented to avoid using general linear programming solvers.</p>
<p>Since <span class="math inline">\(\tau\)</span>-Argus has been transformed to an open source project we have also included an open source solver Soplex as an alternative for Xpress and cplex. We have obtained a licence that is included in the software that grants to the European National Statistical Institutes a non-exclusive, non-transferable, non-sub-licensable, perpetual right to use Soplex version 2.0.x and SCIP version 3.1.x, linked to the <span class="math inline">\(\tau\)</span>-Argus software. This enables you to use the <span class="math inline">\(\tau\)</span>-Argus software withou tbuying a licence for the commercial solvers. However it should benoted that commercial solvers are more powerful and might be needed to solve larger instances.</p>
</section>
<section id="sec-modularapproach" class="level2" data-number="2.10">
<h2 data-number="2.10" class="anchored" data-anchor-id="sec-modularapproach"><span class="header-section-number">2.10</span> The Modular approach<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></h2>
<p>The modular (HiTaS) solution is a heuristic approach to cell suppression in hierarchical tables. Hierarchical tables are specially linked tables: at least one of the spanning variables exhibits a hierarchical structure, <em>i.e</em>. contains (many) sub-totals.</p>
<p>In Fischetti and Salazar (1998) a theoretical framework is presented that should be able to deal with hierarchical and generally linked tables. In what follows, this will be called the mixed integer approach. In this framework, additional constraints to a linear programming problem are generated. The number of added constraints however, grows rapidly when dealing with hierarchical tables, since many dependencies exist between all possible (sub-)tables containing many (sub-)totals. The implemented heuristic approach (HiTaS) deals with a large set of (sub)-tables in a particular order. A non hierarchical table can be considered to be a hierarchical table with just one level. In that case, the approach reduces to the original mixed integer approach and hence provides the optimal solution. In case of a hierarchical table, the approach will provide a sub-optimal solution that minimises the information loss per sub-table, but not necessarily the global information loss of the complete set of hierarchically linked tables.</p>
<p>In the following section, a short description of the approach is given. For a more detailed description of the method, including some examples, see <em>e.g</em>., De Wolf (2002).</p>
<p>HiTaS deals with cell suppression in hierarchical tables using a top-down approach. The first step is to determine the primary unsafe cells in the base-table consisting of all the cells that appear when crossing the hierarchical spanning variables. This way all cells, whether representing a (sub-)total or not, are checked for primary suppression. Knowing all primary unsafe cells, the secondary cell suppressions have to be found in such a way that each (sub-)table of the base-table is protected and that the different tables cannot be combined to undo the protection of any of the other (sub-)tables. The basic idea behind the top-down approach is to start with the highest levels of the variables and calculate the secondary suppressions for the resulting table. The suppressions in the interior of the protected table is then transported to the corresponding marginal cells of the tables that appear when crossing lower levels of the two variables. All marginal cells, both suppressed and not suppressed, are then’fixed’ in the calculation of the secondary suppressions of that lower level table, i.e., they are not allowed to be (secondarily) suppressed. This procedure is then repeated until the tables that are constructed by crossing the lowest levels of the spanning variables are dealt with.</p>
<p>A suppression pattern at a higher level only introduces restrictions on the marginal cells of lower level tables. Calculating secondary suppressions in the interior while keeping the marginal cells fixed, is then independent between the tables on that lower level, i.e., all these (sub)-tables can be dealt with independently of each other. Moreover, added primary suppressions in the interior of a lower level table are dealt with at that same level: secondary suppressions can only occur in the same interior, since the marginal cells are kept fixed.</p>
<p>However, when several empty cells are apparent in a low level table,it might be the case that no solution can be found if one is restricted to suppress interior cells only. Unfortunately,backtracking is then needed.</p>
<p>Obviously, all possible (sub)tables should be dealt with in a particular order, such that the marginal cells of the table under consideration have been protected as the interior of a previously considered table. To that end, certain groups of tables are formed in a specific way (see De Wolf (2002)). All tables within such a group are dealt separately, using the mixed integer approach. The number of tables within a group is determined by the number of parent-categories the variables have one level up in the hierarchy. A parent-category is defined as a category that has one or more sub-categories. Note that the total number of (sub)-tables that have to be considered thus grows rapidly.</p>
<p><strong>Singletons</strong></p>
<p>Singleton cells should be treated with extra care. The single respondent in this cell could easily undo the protection if no extra measures were taken. The most dangerous situation is that there are only two singletons in a row, or one and one other primary unsafe cell. These singletons could easily disclose the other cell.</p>
<p>We have added options for extra singleton protection in the followingsituations.</p>
<ol type="1">
<li><p>If on a row or column of a subtable there are only two singletons and no other primary suppressions.</p></li>
<li><p>If there is only one singleton and one multiple primary unsafe cell.</p></li>
<li><p>If a frequency rule is used, it could happen that two cells on a row/column are primary unsafe, but the sum of the two cells could still be unsafe. In that case it should be prevented that these two cells protect each other.</p></li>
</ol>
<p>Cells within a table sometimes consist of exactly one contributor. Such a cell is called a singleton. Linear sensitivity rules will usually label this cell as (primary) unsafe. When cell suppression is used to protect a table with unsafe cells, these singletons need to be taken care of in a special way.</p>
<p>Within a suppression pattern, contributors in singletons may be able to recalculate other suppressed cells. Obviously, a contributor could always insert its own contribution and thereby recalculate its ownsuppressed cell. This could in turn lead to the possibility of recalculating other suppressed cells in the same suppression pattern. Whenever such a recalculated cell is (primary) unsafe, this means disclosure.</p>
<p>Within the current models used to determine suppression patterns, it is not possible to take all possible situations into account when singletons are part of a suppression pattern. However, an important group of instances of disclosure by singletons, is when a singleton is part of a row with exactly one additional (also primary) suppression.</p>
<ol type="1">
<li><p>If on a row or column of a subtable there are only two singletons and no other primary suppressions.</p></li>
<li><p>If there is only one singleton and one multiple primary unsafe cell.</p></li>
<li><p>If a frequency rule is used, it could happen that two cells on a row/column are primary unsafe, but the sum of the two cells could still be unsafe. In that case it should be prevented that these two cells protect each other.</p></li>
</ol>
<p>Note that the last situation is not really a singleton problem, but this problem is handeled in the same way.</p>
<p>To prevent this kind of disclosure, it would be sufficient to force an additional (third) suppression in the same row. In prior versions of <span class="math inline">\(\tau\)</span>-Argus this was accomplished by increasing the protection levels of one of the (primary) unsafe cells in the row. In short, the protection level of one of the primary suppressed cells was raised in such a way that the other primary suppression would not be able to give sufficient protection. The largest primary unsafe cell in the row got the <em>cell value</em> of the other unsafe cell in the row, plus a small value, as protection level. Indeed, this forces a third suppression inthe row.</p>
<p>However, since the <em>cell value</em> of one of the suppressed cells was involved, this meant that the increased protection level of this cell could become quite large, which would have an effect on the suppression pattern in one of the other dimensions. In certain situations this led to oversuppression.</p>
<p>To circumvent this problem, the newly implemented approach adds a virtual cell to the table. That virtual cell is assigned a value equal to the sum of the two primary suppressed cells in the row, and is given the status '(primary) unsafe'. That virtual cell then only has to be protected against exact disclosure, i.e., it suffices to imposea small protection interval.</p>
<p>The table below shows an example table, displaying the singleton problem. In the first table the values of the cells are given, with inbold, italic the (primary) unsafe cells. The second table shows the names of the cells, where <em>c</em><sub><em>ij</em></sub> stands for the cell with coordinates (i, j).</p>
<table class="table-striped table-hover table">
<caption>Example table to explain Singleton Problem. Bold and italic means (primary) unsafe.</caption>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>Total</strong></th>
<th style="text-align: center;"><strong>X1</strong></th>
<th style="text-align: center;"><strong>X2</strong></th>
<th style="text-align: center;"><strong>X3</strong></th>
<th style="text-align: center;"><strong>X4</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Total</strong></td>
<td style="text-align: center;">227</td>
<td style="text-align: center;">73</td>
<td style="text-align: center;">33</td>
<td style="text-align: center;">93</td>
<td style="text-align: center;">25</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>A</strong></td>
<td style="text-align: center;">146</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;"><strong><em>15</em></strong></td>
<td style="text-align: center;">62</td>
<td style="text-align: center;"><strong><em>17</em></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>B</strong></td>
<td style="text-align: center;">81</td>
<td style="text-align: center;">24</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">31</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
<table class="table-striped table-hover table">
<caption>Names of the cells</caption>
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 13%">
<col style="width: 21%">
<col style="width: 13%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>Total</strong></th>
<th style="text-align: center;"><strong>X1</strong></th>
<th style="text-align: center;"><strong>X2</strong></th>
<th style="text-align: center;"><strong>X3</strong></th>
<th style="text-align: center;"><strong>X4</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Total</strong></td>
<td style="text-align: center;"><span class="math inline">\(c_{00}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{01}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{02}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{03}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{04}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>A</strong></td>
<td style="text-align: center;"><span class="math inline">\(c_{10}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{11}\)</span></td>
<td style="text-align: center;"><strong><em><span class="math inline">\(c_{12}\)</span></em></strong></td>
<td style="text-align: center;"><span class="math inline">\(c_{13}\)</span></td>
<td style="text-align: center;"><strong><em><span class="math inline">\(c_{14}\)</span></em></strong></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>B</strong></td>
<td style="text-align: center;"><span class="math inline">\(c_{20}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{21}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{22}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{23}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(c_{24}\)</span></td>
</tr>
</tbody>
</table>
<p>Now assume that cell <span class="math inline">\(c_{12} = (A,X2)\)</span> is a singleton and cell <span class="math inline">\(c_{14} = (A,X4)\)</span> is unsafe according to a <span class="math inline">\(p\)</span>%-rule with <span class="math inline">\(p=10\)</span>. Hence,cell <span class="math inline">\(c_{14}\)</span> is the only other (primary) unsafe cell in that row. To protect cell <span class="math inline">\(c_{14}\)</span> against disclosure by the contributor of singleton <span class="math inline">\(c_{12}\)</span>, a virtual cell <span class="math inline">\(c_{v}\)</span> is defined with value <span class="math inline">\(32\)</span>. Moreover, that virtual cell is given a small protection interval, <span class="math inline">\((32,33)\)</span> say. The relations that define the table structure, including the virtual cell, are given below:</p>
<table class="table-striped table-hover table">
<caption>Table showing the relations defining table structure of table above</caption>
<tbody>
<tr class="odd">
<td><span class="math inline">\(c_{00} = c_{01} +  c_{02} +  c_{03} +  c_{04}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(c_{10} = c_{11} +  c_{12} +  c_{13} +  c_{04}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(c_{20} = c_{21} +  c_{22} +  c_{23} +  c_{24}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(c_{00} = c_{10} +  c_{20}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(c_{01} = c_{11} +  c_{21}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(c_{02} = c_{12} +  c_{22}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(c_{03} = c_{13} +  c_{23}\)</span></td>
</tr>
<tr class="even">
<td><span class="math inline">\(c_{04} = c_{14} +  c_{24}\)</span></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(c_{v} = c_{12} +  c_{14}\)</span></td>
</tr>
</tbody>
</table>
<p>Within <span class="math inline">\(\tau\)</span>-Argus, this procedure is implemented in both the optimal approach as well as in the modular approach. For the modular approach, this procedure is applied to each subtable separately, whenever a subtable is dealt with within the modular approach.</p>
<p>This special attention to singletons is only given when the other suppressed cell in the same row is a 'true' primary suppression. This is natural, since it has to be done prior to the search for secondary suppressions. In the modular approach, a hierarchical table is divided into many, non-hierarchical, subtables. Secondary suppressions in one table sometimes temporarily become primary suppressions in other tables during the process. I.e., those suppression are not 'true' primary suppressions. It is therefore also natural not to construct virtual cells in case a singleton is in the same row with exactly one other primary suppression that was originally a secondary suppression. This is indeed the way it is implemented in the modular approach.</p>
<p>In previous versions of <span class="math inline">\(\tau\)</span>-Argus a similar procedure was available. But then the additional protection was achieved by increasing the protection level of the singleton cell. This would lead however also in additional protection in other dimensions and would create over-protection</p>
<p><strong>Negative values</strong></p>
<p>The implementation by Fischetti and Salazar does not allow for negative values. However it is not uncommon, that some cells in a table have negative values. Therefore additional measures have been taken. If in a subtable during the process negative values are found ,all cell values are increased such that the lowest value becomes positive. Of course the margins have to be recalculated, but a safe protection pattern will be found.</p>
<section id="references-on-the-modular-method" class="level3" data-number="2.10.1">
<h3 data-number="2.10.1" class="anchored" data-anchor-id="references-on-the-modular-method"><span class="header-section-number">2.10.1</span> References on the modular method</h3>
<ol type="1">
<li>Fischetti, M. and J.J. Salazar-González (1998). Models and Algorithmsfor Optimizing Cell Suppression in Tabular Data with LinearConstraints. Technical Paper, University of La Laguna, Tenerife.</li>
<li>P.P. de Wolf (2002). HiTaS: a heuristic approach to cell suppressionin hierarchical tables. Proceedings of the AMRADS meeting inLuxembourg (2002).</li>
<li>Additional reading on the optimisation models can be found at theCASC-website<a href="http://research.cbs.nl/casc/Related/99wol-heu-r.pdf"><strong>(http://research.cbs.nl/casc/Related/99wol-heu-r.pdf)</strong></a></li>
</ol>
</section>
</section>
<section id="sec-modularlinkedtables" class="level2" data-number="2.11">
<h2 data-number="2.11" class="anchored" data-anchor-id="sec-modularlinkedtables"><span class="header-section-number">2.11</span> The modular approach for linked tables</h2>
<p>When tables are linked through simple linear constraints, cell suppressions must obviously be coordinated between tables. The most typical case is when tables share common cells (usually marginals),i.e., when they are linked through constraints saying literally that cell <span class="math inline">\(X\)</span> of table A is identical to cell <span class="math inline">\(Y\)</span> of table B.</p>
<p>Suppose a set of <span class="math inline">\(N\)</span> tables, <span class="math inline">\(\{T_{1},\dots,T_{N}\}\)</span>, need to be protected. These tables are assumed to be linked. Each table has a hierarchical structure that may differ from the hierarchical structures of the other tables. However, it is assumed that tables using the same spanning variables have hierarchies that can becovered. Loosely speaking this means that a single hierarchy can be constructed such that all hierarchies of the same variable in the <span class="math inline">\(N\)</span> tables are a sub hierarchy of the cover hierarchy. See De Wolf and Giessing (2009) for more details. In the context of pre-planned table production processes which are typically in place in statistical agencies for the production of certain sets of pre-specified standard tabulations, it is normally no problem to satisfy these conditions. Literally speaking, the assumption is that tables in a set of linked tables may present the data in a breakdown by the same spanning variable at various amounts of detail. But only under the condition that, if in one of the tables some categories of a spanning variable are grouped into a certain intermediate sum category, during SDC processing this intermediate sum category is considered in any other table presenting the data in a breakdown of the same spanning variable and at that much detail.</p>
<p>The idea is then as follows. Suppose that the <span class="math inline">\(N\)</span> tables<span class="math inline">\(\{T_{1},\dots,T_{N}\}\)</span> that need to be protected simultaneously, contain <span class="math inline">\(M\)</span> different spanning variables. Since the hierarchies are supposed to be coverable, an <span class="math inline">\(M\)</span>-dimensional table exists having all the specified tables as subtables. The spanning variables will benumbered 1 up to <span class="math inline">\(M\)</span>.</p>
<p>Each spanning variable can have several hierarchies in the specified tables. Denote those hierarchies for spanning variable <span class="math inline">\(i\)</span> by <span class="math inline">\(\mathcal{H}_{1}^{i},\dots,\mathcal{H}_{I_{i}}^{i}\)</span> where <span class="math inline">\(I_{i}\)</span> is the number of different hierarchies of variable <span class="math inline">\(i\)</span>.</p>
<p>Define the <span class="math inline">\(M\)</span>-dimensional table by the table with spanning variables according to hierarchies <span class="math inline">\(G_{1},\dots,G_{M}\)</span> such that, for each <span class="math inline">\(i = 1,\dots,M\)</span> hierarchy <span class="math inline">\(G_{i}\)</span> covers the set of hierarchies <span class="math inline">\(\{\mathcal{H}_{j}^{i}\}\)</span> with <span class="math inline">\(j = 1,\dots,I_{i}\)</span>. This <span class="math inline">\(M\)</span>-dimensional table will be called the cover table. See De Wolf and Giessing (2009) for more details.</p>
<p>Then use the Modular approach (see <a href="#sec-modularapproach" class="quarto-xref"><span>Section 2.10</span></a>) on the cover table <span class="math inline">\(T_{C}\)</span>, but only consider those subtables that are alsosubtables of at least one of the specified tables <span class="math inline">\(T_{1},\dots,T_{N}\)</span> and disregard the other subtables. I.e., the procedure of the Modular approach is followed, but during that process any simple subtable that is not a subtable of any of thetables in the set <span class="math inline">\(\{T_{1},\dots,T_{N}\}\)</span> is skipped. I.e., the orderthe simple subtables will be protected, is the same as in the ‘complete’ Modular approach, only some subtables will be skipped.</p>
<p>See De Wolf and Hundepool (2010) for a practical application of the Adjusted Modular Approach.</p>
<section id="references-on-the-modular-approach-for-linked-tables" class="level3" data-number="2.11.1">
<h3 data-number="2.11.1" class="anchored" data-anchor-id="references-on-the-modular-approach-for-linked-tables"><span class="header-section-number">2.11.1</span> References on the modular approach for linked tables</h3>
<ol type="1">
<li>De Wolf, P.P. and S. Giessing (2009), Adjusting the <span class="math inline">\(\tau\)</span>-Argus modularapproach to deal with linked tables, Data &amp; Knowledge Engineering,Volume 68, Issue 11, pp.&nbsp;1160-1174.</li>
<li>De Wolf, P.P. and A. Hundepool (2010), Three ways to deal with a setof linked SBS tables using <span class="math inline">\(\tau\)</span>-Argus, Privacy in Statistical Databases,J. Domingo-Ferrer and E. Magkos (Eds.), Springer 2010, LNCS 6344 pp.66-74.</li>
</ol>
</section>
</section>
<section id="network-solution-for-large-2-dimensional-tables-with-one-hierarchy" class="level2" data-number="2.12">
<h2 data-number="2.12" class="anchored" data-anchor-id="network-solution-for-large-2-dimensional-tables-with-one-hierarchy"><span class="header-section-number">2.12</span> Network solution for large 2 dimensional tables with one hierarchy</h2>
<p><span class="math inline">\(\tau\)</span>-Argus also contains a solution for the secondary cell suppression based on network flows. This contribution is by Jordi Casto of the Universitat Politècnica de Catalunya in Barcelona. The network flows solution for cell suppression implements a fast heuristic for the protection of statistical data in two-dimensional tables with one hierarchical dimension (1H2D tables). This new heuristic sensibly combines and improves ideas of previous approaches for the secondary cell suppression problem in two-dimensional general, see Castro(1994)and positive tables, see Kelly(1992) and Castro(2003) tables. Details about the heuristic can be found in Castro(1996) and Cox(1995).Unfortunately this approach is only possible for two-dimensional tables with only one hierarchy, due to the limitations of the network flows. Note that the hierarchical variable should be the first variable.</p>
<p>The heuristic is based on the solution of a sequence of shortest-path subproblems that guarantee a feasible pattern of suppressions (i.e.,one that satisfies the protection levels of sensitive cells). Hopefully, this feasible pattern will be close to the optimal one.</p>
<p>The current package is linked with three solvers: CPLEX7.5/8.0 seeILOG(2000) <span class="smallcaps">pprn</span> see Castro(1996), and an efficient implementation of the bidirectional Dijkstra’s algorithm for shortest-paths (that will be denoted as “Dijkstra”) see Ahuja(1993). Later releases of <span class="smallcaps">cplex</span> will also work if the interface routines are the same than for version 8.0. The heuristic can use any of the three solvers for the solution of the shortest path subproblems, although Dijkstra is recommended (and the default one) for efficiency reasons. <span class="smallcaps">cplex</span> is needed if alower bound of the optimal solution want to be computed. The auditing phase can be performed with either <span class="smallcaps">cplex</span> or <span class="smallcaps">pprn</span>.</p>
<p><span class="smallcaps">pprn</span> and Dijkstra were implemented at the Dept. of Statistics and Operations Research of the Universitat Politècnica de Catalunya, and are included in NF CSP. <span class="smallcaps">pprn</span> was originally developed during 1992–1995, but it had to be significantly improved within the CASC project to work with NF CSP. Dijkstra was completely developed in the scope of CASC. The third solver, <span class="smallcaps">cplex</span>, is a commercial tool, and requires purchasing a license. However, <span class="smallcaps">pprn</span> is a fairly good replacement —although not so robust— for the network flows routines of <span class="smallcaps">cplex</span>. Therefore, in principle, there is no need for an external commercial solver, unless lower bounds want to be computed.</p>
<p>Even though two of the three solvers are included in the distribution of NF CSP, this document only describes the features of the heuristic,and from the user’s point of view. A detailed description of <span class="smallcaps">pprn</span> and Dijkstra’s solvers can be found in Castro(1996) and Ahuja(1993), respectively.</p>
<p>The current implementation in <span class="math inline">\(\tau\)</span>-Argus however only uses the Dijkstra and the <span class="smallcaps">pprn</span> solvers. We have restricted ourselves from commercial solvers here as the network flows give already a very fast solution.</p>
<section id="references-on-the-network-solution" class="level3" data-number="2.12.1">
<h3 data-number="2.12.1" class="anchored" data-anchor-id="references-on-the-network-solution"><span class="header-section-number">2.12.1</span> References on the network solution</h3>
<ol type="1">
<li>Ahuja, R.K, Magnanti, T.L., Orlin, J.B., Network Flows, Prentice Hall(1993).</li>
<li>Castro, J., <span class="smallcaps">pprn</span> 1.0, User’s Guide, Technical report DR 94/06 Dept. ofStatistics and Op-erations Research, Universitat Politècnica deCatalunya, Barcelona, Spain, 1994.</li>
<li>Castro, J., Network flows heuristics for complementary cellsuppression: an empirical evaluation and extensions, in LNCS 2316,Inference Control in Statistical Databases, J. Domingo-Ferrer (Ed),(2002) 59–73.</li>
<li>Castro, J., Nabona, N. An implementation of linear and nonlinearmulticommodity network flows. European Journal of Operational Research92, (1996) 37–53.</li>
<li>Cox, L.H., Network models for complementary cell suppression. J. Am.Stat. Assoc. 90, (1995) 1453–1462.</li>
<li>ILOG CPLEX, ILOG CPLEX 7.5 Reference Manual Library, ILOG, (2000).</li>
<li>Kelly, J.P., Golden, B.L, Assad, A.A., Cell Suppression: disclosureprotection for sensitive tabular data, Networks 22, (1992) 28–55.</li>
<li>Castro, J. User’s and programmer’s manual of the network flowsheuristics package for cell suppression in 2D tables Technical ReportDR 2003-07, Dept. of Statistics and Operations Research, UniversitatPolitècnica de Catalunya, Barcelona, Spain,2003;</li>
<li>See<a href="http://research.cbs.nl/casc/deliv/41D5-NF-Tau-Argus.pdf"><em>http://research.cbs.nl/casc/deliv/41D5-NF-Tau-Argus.pdf</em></a></li>
</ol>
</section>
</section>
<section id="controlled-tabular-adjustment12" class="level2" data-number="2.13">
<h2 data-number="2.13" class="anchored" data-anchor-id="controlled-tabular-adjustment12"><span class="header-section-number">2.13</span> Controlled Tabular Adjustment<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></h2>
<p>The purpose of <em>controlled tabular adjustment</em> (also known as <em>minimum-distance controlled tabular adjustment</em> or simply CTA) is to find the closest safe table to the original one. Since CTA is a perturbative method, this goal is achieved by publishing a table where the values of sensitive cells have been modified according to some predefined protection levels, and the remaining non-sensitive cells are minimally changed to guarantee the table additivity.</p>
<p>The example illustrates CTA on a small two-dimensional table with one sensitive cell in bold face, with lower and upper protection levelsequal to five (table (a) of the example). Depending on the 'protection direction' of the sensitive cell, either 'lower' or'upper', which has to be decided, the value to be published for this cell will be respectively less or equal than the original cell value minus the lower protection level, or greater or equal than the original cell value plus the upper protection level. In the example,if the protection direction is 'lower', then the value published orthe sensitive cell should be less or equal than 35; the optimal adjusted table for this case is shown in table (b) of the example. If the protection direction is 'upper', then the value must be great eror equal than 45, as shown in table (c) of the example. In a larger and more complex table, with many sensitive cells, the obtention of the protection directions that provide the minimal changes tonon-sensitives cells is not as easy as in the example. CTA has thus tobe formulated and solved as an optimization problem, in particular as a <em>mixed integer linear problem</em> (MILP).</p>
<p><em>Example of a CTA solution:</em> The cell (M2P3) is a sensitive cell with lower and upper protection level 5. Protected tables with 'lower protection direction' and 'upper protection direction' (i.e., value of sensitive is respectively reduced and increased byfive units).</p>
<table class="table">
<caption>Original table (a)</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">P1</th>
<th style="text-align: right;">P2</th>
<th style="text-align: right;">P3</th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>M1</em></td>
<td style="text-align: right;">20</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">28</td>
<td style="text-align: right;">72</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>M2</em></td>
<td style="text-align: right;">38</td>
<td style="text-align: right;">38</td>
<td style="text-align: right;"><strong>40</strong></td>
<td style="text-align: right;">116</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>M3</em></td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">39</td>
<td style="text-align: right;">42</td>
<td style="text-align: right;">121</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">98</td>
<td style="text-align: right;">101</td>
<td style="text-align: right;">110</td>
<td style="text-align: right;">309</td>
</tr>
</tbody>
</table>
<div>

</div>
<div class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<table class="table">
<caption>Adjusted table - lower protection direction (b)</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">P1</th>
<th style="text-align: right;">P2</th>
<th style="text-align: right;">P3</th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>M1</em></td>
<td style="text-align: right;">15</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">33</td>
<td style="text-align: right;">72</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>M2</em></td>
<td style="text-align: right;">43</td>
<td style="text-align: right;">38</td>
<td style="text-align: right;"><strong>35</strong></td>
<td style="text-align: right;">116</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>M3</em></td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">39</td>
<td style="text-align: right;">42</td>
<td style="text-align: right;">121</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">98</td>
<td style="text-align: right;">101</td>
<td style="text-align: right;">110</td>
<td style="text-align: right;">309</td>
</tr>
</tbody>
</table>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<table class="table">
<caption>Adjusted table - upper protection direction (c)</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">P1</th>
<th style="text-align: right;">P2</th>
<th style="text-align: right;">P3</th>
<th style="text-align: right;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>M1</em></td>
<td style="text-align: right;">25</td>
<td style="text-align: right;">24</td>
<td style="text-align: right;">23</td>
<td style="text-align: right;">72</td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>M2</em></td>
<td style="text-align: right;">33</td>
<td style="text-align: right;">38</td>
<td style="text-align: right;"><strong>45</strong></td>
<td style="text-align: right;">116</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>M3</em></td>
<td style="text-align: right;">40</td>
<td style="text-align: right;">39</td>
<td style="text-align: right;">42</td>
<td style="text-align: right;">121</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">98</td>
<td style="text-align: right;">101</td>
<td style="text-align: right;">110</td>
<td style="text-align: right;">309</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div>
<!--

<table data-quarto-postprocess="true">
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<tbody>
<tr class="odd">
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>P1</p>
</blockquote></td>
<td><blockquote>
<p>P2</p>
</blockquote></td>
<td><blockquote>
<p>P3</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>P1</p>
</blockquote></td>
<td><blockquote>
<p>P2</p>
</blockquote></td>
<td><blockquote>
<p>P3</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>M1</p>
</blockquote></td>
<td><blockquote>
<p>15</p>
</blockquote></td>
<td><blockquote>
<p>24</p>
</blockquote></td>
<td><blockquote>
<p>33</p>
</blockquote></td>
<td><blockquote>
<p>72</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>I</p>
</blockquote></td>
<td><blockquote>
<p>25</p>
</blockquote></td>
<td><blockquote>
<p>24</p>
</blockquote></td>
<td><blockquote>
<p>23</p>
</blockquote></td>
<td><blockquote>
<p>72</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>
<p>M2</p>
</blockquote></td>
<td><blockquote>
<p>43</p>
</blockquote></td>
<td><blockquote>
<p>38</p>
</blockquote></td>
<td><blockquote>
<p>35</p>
</blockquote></td>
<td><blockquote>
<p>116</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>33</p>
</blockquote></td>
<td><blockquote>
<p>38</p>
</blockquote></td>
<td><blockquote>
<p>45</p>
</blockquote></td>
<td><blockquote>
<p>116</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p>M3</p>
</blockquote></td>
<td><blockquote>
<p>40</p>
</blockquote></td>
<td><blockquote>
<p>39</p>
</blockquote></td>
<td><blockquote>
<p>42</p>
</blockquote></td>
<td><blockquote>
<p>121</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>40</p>
</blockquote></td>
<td><blockquote>
<p>39</p>
</blockquote></td>
<td><blockquote>
<p>42</p>
</blockquote></td>
<td><blockquote>
<p>121</p>
</blockquote></td>
</tr>
<tr class="odd">
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>98</p>
</blockquote></td>
<td><blockquote>
<p>101</p>
</blockquote></td>
<td><blockquote>
<p>110</p>
</blockquote></td>
<td><blockquote>
<p>309</p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p>98</p>
</blockquote></td>
<td><blockquote>
<p>101</p>
</blockquote></td>
<td><blockquote>
<p>110</p>
</blockquote></td>
<td><blockquote>
<p>309</p>
</blockquote></td>
</tr>
<tr class="even">
<td><blockquote>
<p><strong><strong>Adjusted table<br />
Lower protection direction (b)</strong></strong></p>
</blockquote></td>
<td><blockquote>

</blockquote></td>
<td><blockquote>
<p><strong><strong>Adjusted table<br />
Upper protection direction (c)</strong></strong></p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

-->
</div>
<p>CTA was introduced in the manuscript Dandekar and Cox(2002) and, independently and in an extended form, in Castro(2006) (in the latter it was named minimum-distance controlled perturbation method). CTA has shown to have both a small disclosure risk see Castro(2012) and small information loss see Castro and González(2014).</p>
<p>The parameters that define any CTA instance are:</p>
<ul>
<li><p>A general table <span class="math inline">\(a_{i}\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>, with <span class="math inline">\(m\)</span> linear relations <span class="math inline">\(Aa=b\)</span>.</p></li>
<li><p>Upper and lower bounds <span class="math inline">\(u\)</span> and <span class="math inline">\(l\)</span> for the cell values, assumed to be known by any attacker: <span class="math inline">\(l \leq a \leq u\)</span>.</p></li>
<li><p>Vector of nonnegative weights associated to the cell perturbations <span class="math inline">\(w_{i}\)</span>, <span class="math inline">\(i=1,\dots,n\)</span>.</p></li>
<li><p>Set <span class="math inline">\(P \subseteq \{1,\dots,n\}\)</span> of sensitive cells.</p></li>
<li><p>Lower and upper protection levels for each primary cell <span class="math inline">\(lpl_{p}\)</span> and <span class="math inline">\(upl_{p}\)</span>, <span class="math inline">\(p \in P\)</span></p></li>
</ul>
<p>CTA finds the safe table x closest to <span class="math inline">\(a\)</span>, using some distance <span class="math inline">\(l{(w)}\)</span></p>
<p><img src="Media/Pictures/10000000000003D20000014D15F11B5A.png" style="width:20cm;height:7cm"></p>
<p><img src="Media/Pictures/2000000700008418000010AE1E94497F.png" style="width:20cm;height:5cm"></p>
<p><img src="Media/Pictures/10000000000003B4000000FF92756D35.png" style="width:20cm;height:5cm"></p>
<p>Problem (3) has <span class="math inline">\(|P|\)</span> binary variables, <span class="math inline">\(2n\)</span> continuous variables and <span class="math inline">\(m + 4|P|\)</span> constraints.The size of (3) is much less than that of the cell suppression problem. For instance, for a table of <span class="math inline">\(8,000\)</span> cells, <span class="math inline">\(800\)</span> primaries, and <span class="math inline">\(4,000\)</span> linear relations, CTA formulates a MILP of 800 binary variables, <span class="math inline">\(16,000\)</span> continuous variables and <span class="math inline">\(7,200\)</span> constraints (these figures would be <span class="math inline">\(8,000\)</span>, <span class="math inline">\(12,800,000\)</span> and <span class="math inline">\(32,000,000\)</span> for cell suppression).</p>
<p>The benefits of CTA are not limited to a smaller size of the resulting MILP problem. CTA can be easily extended with constraints to meet some data quality criteria see Cox et al (2005). It has also been experimentally observed that the information loss of CTA solutions iscomparable (in some instances even better) to that of cell suppression see Castro and Giessing(2006).</p>
<section id="references-on-the-controlled-tabular-adjustment-solution" class="level3" data-number="2.13.1">
<h3 data-number="2.13.1" class="anchored" data-anchor-id="references-on-the-controlled-tabular-adjustment-solution"><span class="header-section-number">2.13.1</span> References on the controlled tabular adjustment solution</h3>
<ol type="1">
<li>L.H. Cox, J.P. Kelly and R. Patil (2005), Computational aspects ofcontrolled tabular adjustment: algorithm and analysis. B. Golden, S.Raghavan, E. Wassil, eds.&nbsp;The Next wave in Computer,Optimization and Decision Technologies, Kluwer, Boston, MA,45–59.</li>
<li>J. Castro, Minimum-distance controlled perturbation methods forlarge-scale tabular data protection, European Journal ofOperational Research, 171 (2006) 39–52.</li>
<li>J. Castro (2012), On assessing the disclosure risk of controlledadjustment methods for statistical tabular data, InternationalJournal of Uncertainty, Fuzziness and Knowledge-Based Systems, 20921–941.</li>
<li>J. Castro and S. Giessing (2006), Testing variants of minimumdistance controlled tabular adjustment, in Monographs of OfficialStatistics. Work session on Statistical Data Confidentiality,Eurostat-Office for Official Publications of the European Communities,Luxembourg, 2006, 333–343. ISBN 92-79-01108-1.</li>
<li>J. Castro and J.A. González (2014), Assessing the information lossof controlled tabular adjustment in two-way tables, Lecture Notesin Computer Science, 8744, 11–23.</li>
<li>R.A. Dandekar and L.H. Cox (2002), Synthetic tabular data: Analternative to complementary cell suppression, manuscript, EnergyInformation Administration, US Department of. Energy.</li>
</ol>
</section>
</section>
<section id="controlled-rounding13" class="level2" data-number="2.14">
<h2 data-number="2.14" class="anchored" data-anchor-id="controlled-rounding13"><span class="header-section-number">2.14</span> Controlled rounding<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></h2>
<p>Controlled rounding is a rounding procedure that, differently from other rounding methods, yields additive rounded tables. That is to say that the rounded values add up to the rounded totals and sub-totals shown in the table. This property not only permits the release of realistic tables but also makes it impossible to reduce the protection by “unpicking” the original values by exploiting the differences in the sums of the rounded values. The Controlled Rounding Procedure (CRP) implemented in <span class="math inline">\(\tau\)</span>-Argus also allows the specification hierarchical tables.</p>
<p>Controlled rounding is a SDC method that is most effective for frequency tables. In fact, this method gives adequate protection to small frequencies by creating uncertainty also with respect to zero values (<em>i.e.</em> empty cells). The same cannot be said for suppression in the way it is implemented now in <span class="math inline">\(\tau\)</span>-Argus.</p>
<section id="restricted-and-non-restricted-controlled-rounding" class="level3" data-number="2.14.1">
<h3 data-number="2.14.1" class="anchored" data-anchor-id="restricted-and-non-restricted-controlled-rounding"><span class="header-section-number">2.14.1</span> Restricted and non-restricted controlled rounding</h3>
<p>In Zero-restricted Controlled Rounding the rounded values are chosen leaving unaltered the original values that are already multiples of the rounding base, while rounding the others to one of the adjacent multiples of this base. The modified values are chosen so that the sum of the absolute differences between the original values and the rounded ones is minimized under the additivity constraint. Therefore, some values will be rounded up or down to the most distant multiple of the base in order to satisfy the constraints. In most cases such a solution can be found but in some cases it cannot. The zero-restriction constraint in CRP can be relaxed allowing the values to be rounded to a non adjacent multiple of the base. This relaxation is controlled by allowing a maximum number of <em>steps</em>. For example, consider rounding the value <span class="math inline">\(7\)</span> when the base equals <span class="math inline">\(5\)</span>. In zero-restricted rounding, the solution can be either <span class="math inline">\(5\)</span> or <span class="math inline">\(10\)</span>. If <span class="math inline">\(1\)</span> step is allowed, the solution can be <span class="math inline">\(0, 5, 10\)</span> or <span class="math inline">\(15\)</span>. In general, let <span class="math inline">\(z\)</span> be the integer to be rounded in base <span class="math inline">\(b\)</span>, then this number can bewritten as <span class="math display">\[{z = {\mathit{ub} + r}},\]</span></p>
<p>where <span class="math inline">\(ub\)</span> is the lower adjacent multiple of <span class="math inline">\(b\)</span> (hence <span class="math inline">\(u\)</span> is the floor value of <span class="math inline">\(z/b\)</span>) and <span class="math inline">\(r\)</span> is the remainder. In the zero-restricted solution the rounded value, <span class="math inline">\(a\)</span>, can take values: <span class="math display">\[\left\{ \begin{matrix}{{a = \mathit{ub}}\mathit{if}{r = 0};} \\{{a = \left\{ \begin{matrix}\mathit{ub} \\{{({u + 1})}b}\end{matrix} \right.}\mathit{if}{r \neq 0.}}\end{matrix} \right.\]</span></p>
<p>If <span class="math inline">\(K\)</span> steps are allowed, then <span class="math inline">\(a\)</span>, can take values:</p>
<p><span class="math display">\[\left\{ \begin{matrix}{{a = \mathit{\max}}{\{{0,{({u + j})}}\}}b,{j = {- K}},\ldots,K,\mathit{if}{r = 0};} \\{{a = \mathit{\max}}{\{{o,{({u + j})}}\}}b,{j = {- K}},\ldots,{({K + 1})},\mathit{if}{r \neq 0.}}\end{matrix} \right.\]</span></p>
</section>
<section id="optimal-first-feasible-and-rapid-solutions14" class="level3" data-number="2.14.2">
<h3 data-number="2.14.2" class="anchored" data-anchor-id="optimal-first-feasible-and-rapid-solutions14"><span class="header-section-number">2.14.2</span> Optimal, first feasible and RAPID solutions<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></h3>
<p>For a given table there could exist more than one controlled rounded solutions; any of these solutions is a <em>feasible</em> solution. The Controlled Rounding Program embedded in <span class="math inline">\(\tau\)</span>-Argus determines the <em>optimal</em> solution by minimising the sum of the absolute distances of the rounded values from the original ones. Denoting the cell values, including the totals and sub-totals, with <span class="math inline">\(z_{i}\)</span> and the correspondingrounded values with <span class="math inline">\(a\)</span><sub>i</sub>, the function that is minimised is <span class="math display">\[{\sum\limits_{i = 1}^{N}{\mid {z_{i} - a_{i}} \mid}},\]</span></p>
<p>where <span class="math inline">\(N\)</span> is the number of cells in a table (including the marginalones). The optimisation procedure for controlled rounding is a rather complex one (<em>NP</em>-complete program), so finding the optimal solution may take a long time for large tables. In fact, the algorithm iteratively builds different rounded tables until it finds the optimal solution. In order to limit the time required to obtain a solution,the algorithm can be stopped when the first feasible solution is found. In many cases, this solution is quite close to the optimal one and it can be found in significantly less time.</p>
<p>The RAPID solution is produced by CRP as an approximated solution when not even a feasible one can be found. This solution is obtained by rounding the internal cells to the closest multiple of the base and then computing the marginal cells by addition. This means that the computed marginal values can be many jumps away from the original value. However, a RAPID solution is produced at each iteration of the search for an optimal one and it will improve (in terms of the loss function) over time. <span class="math inline">\(\tau\)</span>-Argus allows to stop CRP after the first RAPID is produced, but this solution is likely to be very far away from the optimal one.</p>
</section>
<section id="protection-provided-by-controlled-rounding" class="level3" data-number="2.14.3">
<h3 data-number="2.14.3" class="anchored" data-anchor-id="protection-provided-by-controlled-rounding"><span class="header-section-number">2.14.3</span> Protection provided by controlled rounding</h3>
<p>The protection provided by controlled rounding can be assessed by considering the uncertainty about the disclosive true values achieved releasing rounded values; that is the existence interval that an intruder can compute for the rounded value. We assume that also the values of the rounding base, <span class="math inline">\(b\)</span>, and the number of steps allowed, <span class="math inline">\(K\)</span>, are released together with the rounded table. Furthermore, we assume that it is known that the original values are frequencies (hence nonnegative integers).</p>
<section id="zero-restricted-rounding" class="level4" data-number="2.14.3.1">
<h4 data-number="2.14.3.1" class="anchored" data-anchor-id="zero-restricted-rounding"><span class="header-section-number">2.14.3.1</span> Zero-restricted rounding</h4>
<p>Given a rounded value, <span class="math inline">\(a\)</span>, an intruder can compute the following existence intervals for the true value, <span class="math inline">\(z\)</span>: <span class="math display">\[\begin{matrix}{{z \in {\lbrack{0,{b - 1}}\rbrack}}\mathit{if}{a = 0}} \\{{z \in {\lbrack{{{a - b} + 1,}{{a + b} - 1}}\rbrack}}\mathit{if}{a \neq 0.}}\end{matrix}\]</span></p>
<p>For example, if the rounding base is <span class="math inline">\(b=5\)</span> and the rounded value is <span class="math inline">\(a=0\)</span>, a user can determine that the original value is between <span class="math inline">\(0\)</span> and <span class="math inline">\(4\)</span>. If the rounded value is not <span class="math inline">\(0\)</span>, then users can determine that thetrue value is between plus or minus 4 units from the published value.</p>
</section>
<section id="k-step-rounding" class="level4" data-number="2.14.3.2">
<h4 data-number="2.14.3.2" class="anchored" data-anchor-id="k-step-rounding"><span class="header-section-number">2.14.3.2</span> K-step rounding</h4>
<p>As mentioned before, it is assumed that the number of steps allowed is released together with the rounded table. Let <span class="math inline">\(K\)</span> be the number of steps allowed, then an intruder can compute the following existence intervals for the true value <span class="math inline">\(z\)</span>: <span class="math display">\[\begin{matrix}{{z \in {\lbrack{0,{({K + 1})}{b - 1}}\rbrack}}\mathit{if}{a &lt; {({K + 1})}}b} \\{{z \in {\lbrack{{a - {({K + 1})}}{b + 1,}{a + {({K + 1})}}{b - 1}}\rbrack}}\mathit{if}{a \geq {({K + 1})}}\mathit{b.}}\end{matrix}\]</span></p>
<p>For example, assume that for controlled rounding with <span class="math inline">\(b=5\)</span> and <span class="math inline">\(K=1\)</span>, <span class="math inline">\(a=15\)</span>, then a user can determine that <span class="math display">\[{z \in {\lbrack{6,24}\rbrack}}.\]</span></p>
</section>
</section>
<section id="choosing-the-parameters-for-controlled-rounding" class="level3" data-number="2.14.4">
<h3 data-number="2.14.4" class="anchored" data-anchor-id="choosing-the-parameters-for-controlled-rounding"><span class="header-section-number">2.14.4</span> Choosing the parameters for Controlled Rounding</h3>
<p>The parameters that can be chosen for rounding are the rounding base, <span class="math inline">\(b\)</span>, and the number of steps allowed. If their value is released,users (including potential intruders) will be able to compute existence intervals for the true values according to the formulae given above. Then, the choice of the parameters’ values depends on the protection required for the disclosive values. Of course, the larger the existence interval the greater the protection but also the <em>damage</em> caused to the data. The choice of the rounding base, then, should be made by the data protector considering the protection requirements and the damage caused to the data. A discussion on how existence intervals can be related to protection requirements can be found, for example, in Willenborg and de Waal (2001). Below we give some general considerations on the effect of different choices of the rounding base.</p>
<p>Frequencies are disclosive if their values are not larger than a chosen threshold, say <span class="math inline">\(f\)</span>. In <span class="math inline">\(\tau\)</span>-Argus the minimal rounding base is <span class="math inline">\(b=f\)</span>. When this value is chosen, disclosive values can be rounded either to <span class="math inline">\(0\)</span> or to <span class="math inline">\(b\)</span>. Hence, an intruder would know that all published zeros are disclosive values, while he or she could not determine if a published value equal to <span class="math inline">\(b\)</span> is a disclosive value or a larger, safe, one. In some cases this protection can be considered insufficient because it is required that the existence interval for values rounded to zero contains at least one safe value. Then the value of <span class="math inline">\(b\)</span> must be chosen to be greater than <span class="math inline">\(f\)</span> or the number of steps allowed must be greater than zero. It must be stressed, however, that the larger the base and the greater the damage inflicted to the data (including safe values). In some cases, data protector may be happy with a base that is less than the minimum frequency threshold. For example, it could be decided that the width of the existence interval must be not less than the minimum frequency. In this case, the base should be chosen to be the minimal integer not smaller than <span class="math inline">\(f/2\)</span>. Using a smaller base than the minimum safe frequency can be achieved in <span class="math inline">\(\tau\)</span>-Argus by lowering the threshold before computing the table. This “trick” is allowed in rounding because the procedure does not change if the disclosive cells are changed (unlike secondary suppression).</p>
</section>
</section>
<section id="audit" class="level2" data-number="2.15">
<h2 data-number="2.15" class="anchored" data-anchor-id="audit"><span class="header-section-number">2.15</span> Audit</h2>
<p>When a table is protected by cell suppression, by making use of the linear relation between published and suppressed cell values in atable (including its margins), it is always possible for any particular suppressed cell of a table to derive upper and lower bounds for its true value. This holds for either tables with non-negative values, and those tables containing negative values as well, when itis assumed that instead of zero, some other (possibly tight) lower bound for any cell is available to data users in advance of publication. The interval given by these bounds is called the ‘<em>feasibility interval</em>’. The example below illustrates the computation of the feasibility interval in the case of a simple two-dimensional table where all cells may only assume non-negative values:</p>
<table class="table">
<caption>Example</caption>
<thead>
<tr class="header">
<th style="text-align: right;"></th>
<th style="text-align: right;">1</th>
<th style="text-align: right;">2</th>
<th style="text-align: right;">Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><strong>1</strong></td>
<td style="text-align: right;"><span class="math inline">\(X_{11}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(X_{12}\)</span></td>
<td style="text-align: right;">7</td>
</tr>
<tr class="even">
<td style="text-align: right;"><strong>2</strong></td>
<td style="text-align: right;"><span class="math inline">\(X_{21}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(X_{22}\)</span></td>
<td style="text-align: right;">3</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><strong>3</strong></td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">6</td>
</tr>
<tr class="even">
<td style="text-align: right;"><strong>Total</strong></td>
<td style="text-align: right;">9</td>
<td style="text-align: right;">7</td>
<td style="text-align: right;">16</td>
</tr>
</tbody>
</table>
<p>For this table the following linear relations hold: <span class="math display">\[\begin{matrix}{{{X_{11} + X_{12}} = 7}{(\mathit{R1})}} \\{{{X_{21} + X_{22}} = 3}{(\mathit{R2})}} \\{{{X_{11} + X_{21}} = 6}{(\mathit{C1})}} \\{{{X_{12} + X_{22}} = 4}{(\mathit{C2})}} \\ \text{with }{X_{\mathit{ij}} \geq 0}, \forall (i,j) \end{matrix}\]</span></p>
<p>Using linear programming methodology, it is possible to derive systematically for any suppressed cell in a table a upperbound <span class="math inline">\((X^{\mathit{\max}})\)</span> and a lower bound <span class="math inline">\((X_{11}^{\mathit{\min}})\)</span> for the set of feasible values. In the example above, for cell (1,1) these bounds are <span class="math inline">\((X_{11}^{\mathit{\min}}) = 3\)</span> and <span class="math inline">\((X_{11}^{\mathit{\max}})&nbsp;=&nbsp;6\)</span>.</p>
<p>A general mathematical statement for the linear programming problem to compute upper and lower bounds for the suppressed entries of a table is given in Fischetti and Salazar (2000)<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>.</p>
<p>Note that in the current implementation the <span class="math inline">\(\tau\)</span>-Argus audit routine computes upper and lower bounds (i.e.&nbsp;the feasibility intervals) for the suppressed entries of a hierarchical table considering the <em>full</em> set of table relations – even, if the table is a hierarchical table.After obtaining these feasibility intervals, they are compared to the protection intervals (c.f. subsection on protection levels in section 4.3.2. <em>Protection level</em> of the SDC-Handbook, Hundepool et al(2012)) and the result of this comparison will be reported to the user. When a table has been protected properly, the feasibility interval of each primary sensitive cell should cover the protection interval. These intervals will be shown by <span class="math inline">\(\tau\)</span>-Argus.</p>
<section id="auditing-a-hierarchical-table" class="level3" data-number="2.15.1">
<h3 data-number="2.15.1" class="anchored" data-anchor-id="auditing-a-hierarchical-table"><span class="header-section-number">2.15.1</span> Auditing a hierarchical table</h3>
<p>It should be noted that secondary cell suppression algorithms like Modular and Hypercube relying on a backtracking procedure (c.f. the subsection on linked and hierarchical tables in section 4.4.4.<em>Secondary cell suppression in hierarchical and linked tables</em> of theSDC-Handbook, Hundepool et all(2012)) assign secondary suppressions considering only a part of the table relations at a time, e.g.&nbsp;those referring to the ‘current’ subtable. These methods are able to protect each subtable properly in the sense that the feasibility intervals of the sensitive cells indeed cover the protection intervals. But this holds only, if the feasibility intervals are computed considering only the table relations of the particular subtable. But for a hierarchical table, feasibility intervals computed on basis of the set of relations for the <em>full</em> table normally tend to be closer than those computed on basis of separate sets of relations corresponding to individual sub-tables. Hence, in a hierarchical table, it is not unlikely that the Audit routine discovers that some cells were not protected properly.</p>
</section>
<section id="discovering-singleton-problems" class="level3" data-number="2.15.2">
<h3 data-number="2.15.2" class="anchored" data-anchor-id="discovering-singleton-problems"><span class="header-section-number">2.15.2</span> Discovering singleton problems</h3>
<p>Making use of the additional knowledge of a respondent, who is the single respondent to a cell (a so called ‘singleton’), it is possible to derive intervals that are much closer than without this knowledge. The audit routine could be used to identify problems in this respect in the following way: in advance of running the audit routine, set the status of a particular singleton cell from “unsafe” to “safe”.</p>
</section>
</section>
<section id="functional-design-of-tau-argus" class="level2" data-number="2.16">
<h2 data-number="2.16" class="anchored" data-anchor-id="functional-design-of-tau-argus"><span class="header-section-number">2.16</span> Functional design of <span class="math inline">\(\tau\)</span>-Argus</h2>
<p><img src="Media/Pictures/tau_argus_functional_design.png" style="width:14.792cm;height:19.233cm"> <!-- 2000000700004D00000062CFD2BA6125.svm --></p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>See section 4.2 <em>Disclosure risk assessment I: primary sensitive cells</em> of the SDC-Handbook (Hundepool et al.&nbsp;(2012)).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Loeve, Anneke, 2001, Notes on sensitivity measures and protection levels, Research paper, Statistics Netherlands. Available at <a href="">http://neon.vb.cbs.nl/casc/related/marges.pdf</a> <!-- URL no longer works, neither https://research.cbs.nl/casc/related/marges.pdf --><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>See section 5.2 <em>Disclosure risks</em> of the SDC-Handbook (Hundepool et al.&nbsp;(2012)).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>See section 4.6 <em>Information loss measures for tabular data</em> of the SDC-Handbook (Hundepool et al.&nbsp;(2012)).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The section on GHMiter has been contributed by Sarah Giessing, <em>Federal Statistical Office of Germany</em> 65180 Wiesbaden; E-mail: <a href="">sarah.giessing@destatis.de</a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>The optimisation models have been built by a team of researchers headed by Juan-José Salazar-Gonzalez of the University La Laguna, Tenerife, Spain. Other members of the team were: G Andreatta, M. Fischetti, R. Betancort Villalva, M.D.&nbsp;Montesdeoca Sanchez and M. Schoch.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>See section 4.4.4 <em>Secondary cell suppression in hierarchical and linked tables</em> of the SDC Handbook Hundepool et al.&nbsp;(2012).<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>See section 4.5.2 <em>A post-tabular method: Controlled tabular adjustment</em> of the SDC Handbook Hundepool et al.&nbsp;(2012).<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>See section 5.4.3 <em>Rounding</em> of the SDC Handbook Hundepool et al.&nbsp;(2012).<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>For further details see Salazar, Staggermeier and Bycroft (2005 <em>Controlled rounding implementation</em>, UN-ECE Worksession on SDC, Geneva)<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Fischetti, M., Salazar Gonzales, J.J. (2000), <em>Models and Algorithms for Optimizing Cell Suppression Problem in Tabular Data with Linear COnstraints</em>, in Journal of the American Statistical Association, Vol. 95, pp.916<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./01_Introduction.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./03_A_tour_of_τ-ARGUS.html" class="pagination-link" aria-label="A tour of $\tau$-Argus">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">A tour of <span class="math inline">\(\tau\)</span>-Argus</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>